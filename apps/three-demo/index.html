<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D æ‰‹åŠ¿äº¤äº’ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', sans-serif; }
        
        /* UI é¢æ¿ */
        #ui-container {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 280px;
            padding: 20px;
            background: rgba(20, 20, 30, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            color: white;
            z-index: 100;
            pointer-events: auto;
            user-select: none;
            transition: opacity 0.3s;
        }

        h2 { margin: 0 0 15px 0; font-size: 18px; font-weight: 600; letter-spacing: 1px; }
        
        .control-group { margin-bottom: 15px; }
        label { display: block; margin-bottom: 8px; font-size: 12px; opacity: 0.8; }
        
        /* æ ·å¼åŒ–é€‰æ‹©å™¨å’ŒæŒ‰é’® */
        select, input[type="color"] {
            width: 100%;
            padding: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            border-radius: 6px;
            color: white;
            outline: none;
        }
        
        option { background: #1a1a1a; }

        button {
            width: 100%;
            padding: 10px;
            margin-top: 10px;
            background: linear-gradient(45deg, #ff0055, #ff5500);
            border: none;
            border-radius: 6px;
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }

        /* æ‘„åƒå¤´é¢„è§ˆ (è°ƒè¯•ç”¨ï¼Œè®¾ä¸ºå°çª—æˆ–éšè—) */
        #video-preview {
            position: absolute;
            bottom: 20px;
            right: 20px;
            width: 160px;
            height: 120px;
            border-radius: 10px;
            transform: scaleX(-1); /* é•œåƒ */
            opacity: 0.5;
            z-index: 90;
            object-fit: cover;
            border: 2px solid rgba(255, 255, 255, 0.2);
        }

        #loading {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            text-shadow: 0 0 10px rgba(255,0,85,0.8);
        }

        /* çŠ¶æ€æŒ‡ç¤ºç¯ */
        .status {
            display: inline-block;
            width: 8px; height: 8px;
            border-radius: 50%;
            background: #ff3333;
            margin-right: 8px;
        }
        .status.active { background: #33ff33; box-shadow: 0 0 8px #33ff33; }
    </style>
    
    <!-- å¼•å…¥ Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- å¼•å…¥ MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="loading">æ­£åœ¨åˆå§‹åŒ–è§†è§‰å¼•æ“...</div>

    <div id="ui-container">
        <h2>âœ¨ ç²’å­æ§åˆ¶å™¨</h2>
        
        <div class="control-group">
            <div style="display:flex; align-items:center; margin-bottom:10px;">
                <span id="cam-status" class="status"></span>
                <span style="font-size:12px;">æ‰‹åŠ¿è¿½è¸ªçŠ¶æ€</span>
            </div>
        </div>

        <div class="control-group">
            <label>é€‰æ‹©æ¨¡å‹å½¢çŠ¶</label>
            <select id="shape-select">
                <option value="heart">ğŸ’– çˆ±å¿ƒ (Heart)</option>
                <option value="flower">ğŸŒ¸ æ›¼é™€ç½—èŠ± (Flower)</option>
                <option value="saturn">ğŸª åœŸæ˜Ÿ (Saturn)</option>
                <option value="buddha">ğŸ§˜ ç¦…æ„ (Meditate)</option>
                <option value="fireworks">ğŸ† çƒŸèŠ± (Fireworks)</option>
            </select>
        </div>

        <div class="control-group">
            <label>ç²’å­é¢œè‰²</label>
            <input type="color" id="color-picker" value="#ff0055">
        </div>

        <button id="fullscreen-btn">â›¶ å…¨å±æ¨¡å¼</button>
        
        <div style="margin-top:15px; font-size:11px; color:#aaa; line-height:1.4;">
            ä½¿ç”¨è¯´æ˜:<br>
            1. å…è®¸æ‘„åƒå¤´æƒé™<br>
            2. ä¸¾èµ·å•æ‰‹æˆ–åŒæ‰‹<br>
            3. <b>å¼ å¼€æ‰‹æŒ</b> = ç²’å­æ‰©æ•£/æ”¾å¤§<br>
            4. <b>æ¡æ‹³/æåˆ</b> = ç²’å­èšæ‹¢/ç¼©å°
        </div>
    </div>

    <video id="video-preview" playsinline></video>

    <script>
        // ================= é…ç½®å‚æ•° =================
        const PARTICLE_COUNT = 15000;
        const PARTICLE_SIZE = 0.05;
        let currentShape = 'heart';
        let targetColor = new THREE.Color(0xff0055);
        
        // äº¤äº’å˜é‡
        let handScale = 1.0;     // æ‰‹åŠ¿æ§åˆ¶çš„ç¼©æ”¾
        let handSpread = 0.0;    // æ‰‹åŠ¿æ§åˆ¶çš„æ‰©æ•£
        let isHandDetected = false;

        // ================= Three.js åˆå§‹åŒ– =================
        const scene = new THREE.Scene();
        // æ·»åŠ ä¸€ç‚¹é›¾æ•ˆå¢åŠ æ·±é‚ƒæ„Ÿ
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);

        // ================= ç²’å­ç³»ç»Ÿæ ¸å¿ƒ =================
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(PARTICLE_COUNT * 3);
        const targetPositions = new Float32Array(PARTICLE_COUNT * 3); // ç›®æ ‡å½¢çŠ¶çš„åæ ‡
        
        // åˆå§‹åŒ–æ‰€æœ‰ç‚¹åœ¨åŸç‚¹
        for(let i = 0; i < PARTICLE_COUNT * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 10;
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        const material = new THREE.PointsMaterial({
            color: targetColor,
            size: PARTICLE_SIZE,
            sizeAttenuation: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // ================= å½¢çŠ¶ç”Ÿæˆç®—æ³• =================
        function getShapeData(shapeName) {
            const arr = [];
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                let x, y, z;
                
                switch (shapeName) {
                    case 'heart':
                        // 3Dçˆ±å¿ƒå…¬å¼
                        const t = Math.random() * Math.PI * 2;
                        const p = Math.random() * Math.PI * 2;
                        // è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒå¸¸è§çš„å‚æ•°åŒ–çˆ±å¿ƒ
                        x = 16 * Math.pow(Math.sin(t), 3);
                        y = 13 * Math.cos(t) - 5 * Math.cos(2*t) - 2 * Math.cos(3*t) - Math.cos(4*t);
                        z = (Math.random()-0.5) * 4; // ç»™ä¸€ç‚¹åšåº¦
                        // å½’ä¸€åŒ–ç¼©æ”¾
                        x *= 0.1; y *= 0.1;
                        break;

                    case 'flower':
                        // é»„é‡‘è§’èºæ—‹ (Phyllotaxis)
                        const angle = i * 137.5 * (Math.PI / 180);
                        const r = 0.04 * Math.sqrt(i);
                        x = r * Math.cos(angle);
                        y = r * Math.sin(angle);
                        z = (Math.random() - 0.5) * (2 - r/2); // ä¸­å¿ƒåšï¼Œè¾¹ç¼˜è–„
                        break;

                    case 'saturn':
                        // 70% ç²’å­ç»„æˆçƒä½“ï¼Œ30% ç»„æˆå…‰ç¯
                        if (Math.random() > 0.3) {
                            // çƒä½“
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos((Math.random() * 2) - 1);
                            const rad = 1.2;
                            x = rad * Math.sin(phi) * Math.cos(theta);
                            y = rad * Math.sin(phi) * Math.sin(theta);
                            z = rad * Math.cos(phi);
                        } else {
                            // å…‰ç¯
                            const ang = Math.random() * Math.PI * 2;
                            const radRing = 1.8 + Math.random() * 1.5;
                            x = radRing * Math.cos(ang);
                            z = radRing * Math.sin(ang);
                            y = (Math.random() - 0.5) * 0.1; // éå¸¸è–„
                        }
                        // ç¨å¾®å€¾æ–œ
                        const tx = x, ty = y, tz = z;
                        x = tx * Math.cos(0.4) - ty * Math.sin(0.4);
                        y = tx * Math.sin(0.4) + ty * Math.cos(0.4);
                        break;

                    case 'buddha':
                        // ç”¨ç®€å•çš„å‡ ä½•ä½“æ¨¡æ‹Ÿæ‰“åçš„å½¢çŠ¶ (çƒä½“å †å )
                        const seed = Math.random();
                        if (seed < 0.4) {
                            // èº«ä½“ (å¤§æ¤­çƒ)
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos((Math.random() * 2) - 1);
                            x = 1.2 * Math.sin(phi) * Math.cos(theta);
                            y = 1.0 * Math.sin(phi) * Math.sin(theta) - 0.5;
                            z = 1.0 * Math.cos(phi);
                        } else if (seed < 0.6) {
                            // å¤´ (å°çƒ)
                            const theta = Math.random() * Math.PI * 2;
                            const phi = Math.acos((Math.random() * 2) - 1);
                            x = 0.5 * Math.sin(phi) * Math.cos(theta);
                            y = 0.5 * Math.sin(phi) * Math.sin(theta) + 1.0;
                            z = 0.5 * Math.cos(phi);
                        } else {
                            // è…¿éƒ¨ç›˜å (åœ†ç¯åˆ‡ç‰‡)
                            const ang = Math.random() * Math.PI * 2;
                            const radL = 1.2 + Math.random() * 0.5;
                            x = radL * Math.cos(ang);
                            z = radL * Math.sin(ang);
                            y = -1.2 + (Math.random() * 0.4);
                        }
                        break;
                        
                    case 'fireworks':
                        // éšæœºçˆ†ç‚¸çƒä½“
                        const ft = Math.random() * Math.PI * 2;
                        const fp = Math.acos((Math.random() * 2) - 1);
                        const fr = Math.random() * 3.5; // å¤§åŠå¾„
                        x = fr * Math.sin(fp) * Math.cos(ft);
                        y = fr * Math.sin(fp) * Math.sin(ft);
                        z = fr * Math.cos(fp);
                        break;
                }
                arr.push(x, y, z);
            }
            return arr;
        }

        function updateTargetShape(shape) {
            const data = getShapeData(shape);
            for(let i = 0; i < data.length; i++) {
                targetPositions[i] = data[i];
            }
        }

        // åˆå§‹åŒ–é»˜è®¤å½¢çŠ¶
        updateTargetShape(currentShape);

        // ================= MediaPipe Hands é›†æˆ =================
        const videoElement = document.getElementById('video-preview');
        
        function onResults(results) {
            document.getElementById('loading').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                document.getElementById('cam-status').classList.add('active');
                
                // è·å–ç¬¬ä¸€åªæ‰‹çš„æ•°æ®
                const landmarks = results.multiHandLandmarks[0];
                
                // è®¡ç®—é€»è¾‘ï¼š
                // 1. ç¼©æ”¾æ§åˆ¶ï¼šè®¡ç®— 0å·ç‚¹(æ‰‹è…•) å’Œ 9å·ç‚¹(ä¸­æŒ‡æ ¹éƒ¨) çš„è·ç¦»ä½œä¸ºåŸºå‡†ï¼Œ
                //    æˆ–è€…è®¡ç®— 4å·ç‚¹(æ‹‡æŒ‡) å’Œ 8å·ç‚¹(é£ŸæŒ‡) çš„è·ç¦» (Pinch)ã€‚
                //    è¿™é‡Œæˆ‘ä»¬ç”¨æ‰‹æŒå¼ å¼€ç¨‹åº¦ï¼šè®¡ç®— 0(æ‰‹è…•) åˆ° 12(ä¸­æŒ‡æŒ‡å°–) çš„è·ç¦»ã€‚
                
                const wrist = landmarks[0];
                const middleTip = landmarks[12];
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // è®¡ç®—æ‰‹æŒå±•å¼€è·ç¦» (0 -> 12)
                const palmOpenDist = Math.sqrt(
                    Math.pow(wrist.x - middleTip.x, 2) + 
                    Math.pow(wrist.y - middleTip.y, 2)
                );

                // è®¡ç®—æåˆè·ç¦» (4 -> 8)
                const pinchDist = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) + 
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );
                
                // æ˜ å°„æ•°å€¼ (è¿™äº›ç³»æ•°éœ€è¦æ ¹æ®æ‘„åƒå¤´å®é™…ä½“éªŒå¾®è°ƒ)
                // palmOpenDist é€šå¸¸åœ¨ 0.2 (æ¡æ‹³) åˆ° 0.5 (å¼ å¼€) ä¹‹é—´
                
                // ç›®æ ‡ç¼©æ”¾ï¼šæ‰‹å¼ å¼€è¶Šå¤§ï¼Œæ¨¡å‹è¶Šå¤§
                let targetScale = 1.0 + (palmOpenDist - 0.3) * 3; 
                targetScale = Math.max(0.2, Math.min(targetScale, 3.0)); // é™åˆ¶èŒƒå›´

                // ç›®æ ‡æ‰©æ•£ï¼šæåˆæ—¶ç²’å­èšæ‹¢ï¼Œå¼ å¼€æ—¶ç²’å­æ¾æ•£
                // pinchDist å°äº 0.05 è§†ä¸ºæåˆ
                let targetSpread = (pinchDist < 0.1) ? 0.0 : (pinchDist * 2.0);
                
                // å¹³æ»‘æ’å€¼ï¼Œé¿å…æŠ–åŠ¨
                handScale += (targetScale - handScale) * 0.1;
                handSpread += (targetSpread - handSpread) * 0.1;

            } else {
                isHandDetected = false;
                document.getElementById('cam-status').classList.remove('active');
                // æ— æ‰‹åŠ¿æ—¶ç¼“æ…¢æ¢å¤é»˜è®¤
                handScale += (1.0 - handScale) * 0.05;
                handSpread += (0.0 - handSpread) * 0.05;
            }
        }

        const hands = new Hands({locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 320,
            height: 240
        });
        
        // å¯åŠ¨æ‘„åƒå¤´
        cameraUtils.start().catch(err => {
            console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", err);
            document.getElementById('loading').innerText = "æ‘„åƒå¤´è®¿é—®è¢«æ‹’ç»æˆ–å‡ºé”™";
        });

        // ================= äº‹ä»¶ç›‘å¬ =================
        
        // å½¢çŠ¶åˆ‡æ¢
        document.getElementById('shape-select').addEventListener('change', (e) => {
            currentShape = e.target.value;
            updateTargetShape(currentShape);
        });

        // é¢œè‰²åˆ‡æ¢
        document.getElementById('color-picker').addEventListener('input', (e) => {
            targetColor.set(e.target.value);
        });

        // å…¨å±
        document.getElementById('fullscreen-btn').addEventListener('click', () => {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                }
            }
        });

        // çª—å£å¤§å°è°ƒæ•´
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // ================= åŠ¨ç”»å¾ªç¯ =================
        
        // é¼ æ ‡äº¤äº’å¤‡é€‰ (å¦‚æœæ²¡æœ‰æ‘„åƒå¤´)
        let mouseX = 0;
        let mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX - window.innerWidth / 2) * 0.001;
            mouseY = (e.clientY - window.innerHeight / 2) * 0.001;
        });

        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const time = clock.getElapsedTime();

            // 1. ç²’å­é¢œè‰²å¹³æ»‘è¿‡æ¸¡
            material.color.lerp(targetColor, 0.05);

            // 2. ç²’å­ä½ç½®æ›´æ–° (Morphing)
            const positionsArray = geometry.attributes.position.array;
            
            // æ—‹è½¬æ•´ä¸ªç²’å­ç¾¤
            particles.rotation.y += 0.002;
            particles.rotation.x += (mouseY - particles.rotation.x) * 0.05;
            particles.rotation.z += (mouseX - particles.rotation.z) * 0.05;

            // æ ¹æ®æ‰‹åŠ¿è°ƒæ•´ç¼©æ”¾
            // å¹³æ»‘ç¼©æ”¾
            particles.scale.setScalar(handScale);

            for(let i = 0; i < PARTICLE_COUNT; i++) {
                const px = i * 3;
                const py = i * 3 + 1;
                const pz = i * 3 + 2;

                const tx = targetPositions[px];
                const ty = targetPositions[py];
                const tz = targetPositions[pz];

                // åŸºç¡€å½¢çŠ¶æ’å€¼é€Ÿåº¦
                const lerpSpeed = 0.03 + Math.random() * 0.02;

                // è®¡ç®—å½“å‰ç‚¹åˆ°ç›®æ ‡ç‚¹çš„å‘é‡
                let dx = tx - positionsArray[px];
                let dy = ty - positionsArray[py];
                let dz = tz - positionsArray[pz];

                // å¦‚æœæœ‰æ‰©æ•£ (handSpread)ï¼Œç»™ç›®æ ‡ä½ç½®å¢åŠ å™ªç‚¹åç§»
                // æ‰‹æŒè¶Šå¼ å¼€/æˆ–è€…æåˆè·ç¦»è¶Šå¤§ï¼Œspreadå½±å“
                // è¿™é‡Œé€»è¾‘ï¼šæåˆ=ç´§å‡‘ï¼Œå¼ å¼€=æ‰©æ•£(ç‚¸å¼€æ•ˆæœ)
                // æˆ‘ä»¬ä½¿ç”¨ handSpread å˜é‡æ¥æ·»åŠ ä¸€ç‚¹éšæœºåç§»
                
                // å®æ—¶ä½ç½®æ›´æ–° = å½“å‰ + (ç›®æ ‡ - å½“å‰) * é€Ÿåº¦
                positionsArray[px] += dx * lerpSpeed;
                positionsArray[py] += dy * lerpSpeed;
                positionsArray[pz] += dz * lerpSpeed;

                // æ·»åŠ å¾®å°çš„æµ®åŠ¨åŠ¨ç”»ï¼Œè®©ç²’å­çœ‹èµ·æ¥æ˜¯æ´»çš„
                positionsArray[px] += Math.sin(time * 2 + py) * 0.005;
                positionsArray[py] += Math.cos(time * 1.5 + px) * 0.005;

                // æ‰‹åŠ¿æ‰©æ•£æ•ˆæœï¼šå¦‚æœæ£€æµ‹åˆ° spread å€¼å¤§ï¼Œå¼ºè¡Œæ¨å¼€ç²’å­
                if (isHandDetected && handSpread > 0.1) {
                    // ç®€å•çš„å¸ƒæœ—è¿åŠ¨æ‰©æ•£
                    positionsArray[px] += (Math.random() - 0.5) * handSpread * 0.5;
                    positionsArray[py] += (Math.random() - 0.5) * handSpread * 0.5;
                    positionsArray[pz] += (Math.random() - 0.5) * handSpread * 0.5;
                }
            }

            geometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>